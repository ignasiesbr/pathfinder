{"version":3,"sources":["DataStructures/Node.js","DataStructures/Queue.js","DataStructures/Stack.js","DataStructures/PriorityQueue.js","DataStructures/Graph.js","utils/constants.js","utils/helpersGraph.js","utils/helpersGrid.js","AlgoSlice.js","components/Cell2.js","components/Pathfinder.js","components/Header.js","components/Info.js","App.js","index.js"],"names":["getIndex","list","node","index","count","Node","value","this","adjacents","pred","distance","Number","MAX_SAFE_INTEGER","g","f","h","weight","push","p","splice","map","adj","dist","Queue","queue","item","shift","length","Stack","stack","pop","PriorityQueue","heapArray","currentSize","console","log","i","mc","minChild","tmp","Math","floor","k","percUp","retval","percDown","val","amt","done","mKey","getValue","calculateY","endValue","acc","Graph","edgeDirection","DIRECTED","nodes","Map","source","destination","sourceNode","addVertex","destinationNode","addAdjacent","UNDIRECTED","has","get","vertex","set","current","values","removeAdjacent","delete","getAdjacents","forEach","getWeight","getDistance","s","key","first","visited","visitList","add","isEmpty","remove","setToInfinity","visitedList","getPred","setPred","start","setDistance","graph","dijkstra","pq","currentNode","delMin","nextNode","newDist","decreaseKey","startNode","endNode","openList","closedList","xEnd","yEnd","currentIndex","slice","concat","path","curr","reverse","filter","closedNode","xCurr","yCurr","pow","cont","openNode","pos","bfs2","dfs2","a_star","Symbol","addEdge","cols","addWeight","nodeClicked","getVertex","nodeAdj","isUndirected","setWeight","rows","generateGraph","generateEmptyGrid","Array","fill","initialState","selectedAlgorithm","visitPath","foundPath","grid","end","isDragging","addingWall","latestDrag","itemDragging","graphChange","type","algoSlice","createSlice","name","reducers","setStart","reducer","state","action","payload","prepare","newStart","setEnd","newEnd","setGrid","clearGrid","setSelected","setVisitPath","setFoundPath","setDragging","b","setAddingWall","isAdding","setLatestDrag","latest","newCell","setItemDragging","setGraphChange","actions","generateClassName","Cell2","React","memo","cellVal","draggable","onDragStart","onDragOver","e","target","getAttribute","onDragEnd","onClick","newVal","obj","handleClick","className","mapDispatch","connect","mapDispatchToProps","isDraggin","useState","setGraph","useRef","useEffect","parseInt","running","setRunning","runningRef","endRef","startRef","selectedRef","runSimulation","useCallback","found","n","helper","a","async","idx","setTimeout","runClick","resList","getAlgo","bind","getPredList","paths","removeOthers","cell","removeVertex","restoreEdge","newGraph","handleClear","selected","defaultValue","onChange","handleDropdownChange","id","algoList","getInfo","App","store","configureStore","algoReducer","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.d07e5126.chunk.js","sourcesContent":["const getIndex = (list, node) => {\r\n    let index = -1;\r\n    let count = 0;\r\n    for (let pair of list) {\r\n      if (pair[0] === node) {\r\n        index = count;\r\n        break;\r\n      }\r\n      count++;\r\n    }\r\n    return index;\r\n  };\r\n  \r\n  class Node {\r\n    constructor(value) {\r\n      this.value = value;\r\n      this.adjacents = [];\r\n      this.pred = null;\r\n      this.distance = Number.MAX_SAFE_INTEGER;\r\n\r\n      //vbles for a*\r\n      this.g = 0;\r\n      this.f = 0;\r\n      this.h = 0;\r\n    }\r\n  \r\n    addAdjacent(node, weight) {\r\n      this.adjacents.push([node, weight]);\r\n    }\r\n  \r\n    setPred(p) {\r\n      this.pred = p;\r\n    }\r\n\r\n    getPred() {\r\n      return this.pred\r\n    }\r\n\r\n    removeAdjacent(node) {\r\n      let index = getIndex(this.adjacents, node);\r\n      if (index > -1) {\r\n        this.adjacents.splice(index, 1);\r\n        return node;\r\n      }\r\n    }\r\n  \r\n    getAdjacents() {\r\n      let adjacents = this.adjacents.map(adj => adj[0]);\r\n      return adjacents;\r\n    }\r\n  \r\n    getWeight(node) {\r\n      let index = getIndex(this.adjacents, node);\r\n      let pair = this.adjacents[index];\r\n      return pair[1];\r\n    }\r\n\r\n    setWeight(node, weight) {\r\n      let index = getIndex(this.adjacents, node);\r\n      let pair = this.adjacents[index];\r\n      pair[1] = weight;\r\n\r\n    }\r\n  \r\n    isAdjacent(node) {\r\n      return getIndex(this.adjacents, node) > -1;\r\n    }\r\n  \r\n    getValue() {\r\n      return this.value;\r\n    }\r\n  \r\n    getDistance() {\r\n      return this.distance;\r\n    }\r\n  \r\n    setDistance(dist) {\r\n      this.distance = dist;\r\n    }\r\n  }\r\n  \r\n  export default Node;\r\n  ","\r\nclass Queue {\r\n    constructor() {\r\n        this.queue = []\r\n    };\r\n\r\n    add(item) {\r\n        this.queue.push(item);\r\n    }\r\n\r\n    remove(){\r\n        return this.queue.shift();\r\n    }\r\n\r\n    isEmpty() {\r\n        return this.queue.length === 0;\r\n    }\r\n    \r\n}\r\n\r\nexport default Queue;\r\n","class Stack {\r\n    constructor() {\r\n        this.stack = [];\r\n    }\r\n\r\n    push(item) {\r\n        this.stack.push(item);\r\n    };\r\n\r\n    pop() {\r\n        return this.stack.pop();\r\n    }\r\n\r\n    isEmpty() {\r\n        return this.stack.length === 0;\r\n    }\r\n}\r\n\r\nexport default Stack;","class PriorityQueue {\r\n  constructor() {\r\n    this.heapArray = [[0, 0]];\r\n    this.currentSize = 0;\r\n  }\r\n\r\n  printHeap() {\r\n    console.log(this.heapArray);\r\n  }\r\n\r\n  percDown(i) {\r\n    while (i * 2 <= this.currentSize) {\r\n      let mc = this.minChild(i);\r\n      if (this.heapArray[i][0] > this.heapArray[mc][0]) {\r\n        let tmp = this.heapArray[i];\r\n        this.heapArray[i] = this.heapArray[mc];\r\n        this.heapArray[mc] = tmp;\r\n      }\r\n      i = mc;\r\n    }\r\n  }\r\n\r\n  minChild(i) {\r\n    if (i * 2 > this.currentSize) {\r\n      return -1;\r\n    } else {\r\n      if (i * 2 + 1 > this.currentSize) {\r\n        return i * 2;\r\n      } else {\r\n        if (this.heapArray[i * 2][0] < this.heapArray[i * 2 + 1][0]) {\r\n          return i * 2;\r\n        } else {\r\n          return i * 2 + 1;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  percUp(i) {\r\n    while (Math.floor(i / 2) > 0) {\r\n      if (this.heapArray[i][0] < this.heapArray[Math.floor(i / 2)][0]) {\r\n        let tmp = this.heapArray[Math.floor(i / 2)];\r\n        this.heapArray[Math.floor(i / 2)] = this.heapArray[i];\r\n        this.heapArray[i] = tmp;\r\n      }\r\n      i = Math.floor(i / 2);\r\n    }\r\n  }\r\n\r\n  add(k) {\r\n    this.heapArray.push(k);\r\n    this.currentSize += 1;\r\n    this.percUp(this.currentSize);\r\n  }\r\n\r\n  delMin() {\r\n    let retval = this.heapArray[1][1];\r\n    this.heapArray[1] = this.heapArray[this.currentSize];\r\n    this.currentSize = this.currentSize - 1;\r\n    this.heapArray.pop();\r\n    this.percDown(1);\r\n    return retval;\r\n  }\r\n\r\n  isEmpty() {\r\n    return this.currentSize === 0;\r\n  }\r\n\r\n  decreaseKey(val, amt) {\r\n    // console.log(val);\r\n    let done = false;\r\n    let i = 1;\r\n    let mKey = 0;\r\n    while (!done && i <= this.currentSize) {\r\n      // console.log(this.heapArray[i][1]);\r\n      if (this.heapArray[i][1].getValue() === val.getValue()) {\r\n        // console.log(\"gets to decreasekye\");\r\n        done = true;\r\n        mKey = i;\r\n      } else {\r\n        i = i + 1;\r\n      }\r\n    }\r\n    if (mKey > 0) {\r\n      this.heapArray[mKey] = [amt, this.heapArray[mKey][1]];\r\n      this.percUp(mKey);\r\n    }\r\n  }\r\n}\r\n\r\nexport default PriorityQueue;\r\n","import Node from \"./Node\";\r\nimport Queue from \"./Queue\";\r\nimport Stack from \"./Stack\";\r\nimport PriorityQueue from \"./PriorityQueue\";\r\nimport {cols}  from '../utils/constants';\r\n\r\nlet calculateY = (endValue, acc) => {\r\n  if (endValue < cols) {\r\n    return acc;\r\n  } else {\r\n    let newVal = endValue - cols;\r\n    let newAcc = acc + 1;\r\n    return calculateY(newVal, newAcc);\r\n  }\r\n};\r\n\r\nclass Graph {\r\n  constructor(edgeDirection = Graph.DIRECTED) {\r\n    this.nodes = new Map();\r\n    this.edgeDirection = edgeDirection;\r\n  }\r\n\r\n  addEdge(source, destination, weight = 1) {\r\n    const sourceNode = this.addVertex(source);\r\n    const destinationNode = this.addVertex(destination);\r\n\r\n    sourceNode.addAdjacent(destinationNode, weight);\r\n\r\n    if (this.edgeDirection === Graph.UNDIRECTED) {\r\n      destinationNode.addAdjacent(sourceNode, weight);\r\n    }\r\n\r\n    return [sourceNode, destinationNode];\r\n  }\r\n\r\n  addVertex(value) {\r\n    if (this.nodes.has(value)) {\r\n      return this.nodes.get(value);\r\n    } else {\r\n      const vertex = new Node(value);\r\n      this.nodes.set(value, vertex);\r\n      return vertex;\r\n    }\r\n  }\r\n\r\n  removeVertex(value) {\r\n    const current = this.nodes.get(value);\r\n    if (current) {\r\n      for (const node of this.nodes.values()) {\r\n        node.removeAdjacent(current);\r\n      }\r\n    }\r\n    return this.nodes.delete(value);\r\n  }\r\n\r\n  removeEdge(source, destination) {\r\n    const sourceNode = this.nodes.get(source);\r\n    const destinationNode = this.nodes.get(destination);\r\n\r\n    if (sourceNode && destinationNode) {\r\n      sourceNode.removeAdjacent(destinationNode);\r\n\r\n      if (this.edgeDirection === Graph.UNDIRECTED) {\r\n        destinationNode.removeAdjacent(sourceNode);\r\n      }\r\n    }\r\n\r\n    return [sourceNode, destinationNode];\r\n  }\r\n\r\n  printConnections() {\r\n    for (let node of this.nodes) {\r\n      let val = node[1].getValue();\r\n      node[1]\r\n        .getAdjacents()\r\n        .forEach(adj =>\r\n          console.log(\r\n            `( ${val} , ${adj.getValue()}, weight: ${node[1].getWeight(\r\n              adj\r\n            )}, dist: ${node[1].getDistance()} )`\r\n          )\r\n        );\r\n    }\r\n  }\r\n\r\n  getConnections() {\r\n    let s = \"\";\r\n    for (let node of this.nodes) {\r\n      let val = node[1].getValue();\r\n      node[1]\r\n        .getAdjacents()\r\n        .forEach(\r\n          adj =>\r\n            (s = s+\r\n              `( ${val} , ${adj.getValue()} , ${node[1].getWeight(adj)} )` +\r\n              \"\\n\")\r\n        );\r\n    }\r\n    return s;\r\n  }\r\n\r\n  getVertex(key) {\r\n    return this.nodes.get(key);\r\n  }\r\n\r\n  *bfs(first) {\r\n    const visited = new Map();\r\n    const visitList = new Queue();\r\n\r\n    visitList.add(first);\r\n\r\n    while (!visitList.isEmpty()) {\r\n      const node = visitList.remove();\r\n      if (node && !visited.has(node)) {\r\n        yield node;\r\n        visited.set(node);\r\n        node.getAdjacents().forEach(adj => visitList.add(adj));\r\n      }\r\n    }\r\n  }\r\n\r\n  *dfs(first) {\r\n    const visited = new Map();\r\n    const visitList = new Stack();\r\n\r\n    visitList.add(first);\r\n\r\n    while (!visitList.isEmpty()) {\r\n      const node = visitList.remove();\r\n      if (node && !visited.has(node)) {\r\n        yield node;\r\n        visited.set(node);\r\n        node.getAdjacents().forEach(adj => visitList.add(adj));\r\n      }\r\n    }\r\n  }\r\n\r\n  bfs2(first) {\r\n    console.log(\"running bfs\");\r\n    const visited = new Map();\r\n    const visitList = new Queue();\r\n    this.setToInfinity();\r\n    visitList.add(first);\r\n\r\n    const visitedList = [];\r\n\r\n    while (!visitList.isEmpty()) {\r\n      const node = visitList.remove();\r\n      if (node && !visited.has(node)) {\r\n        visitedList.push(node.value);\r\n        visited.set(node);\r\n        node.getAdjacents().forEach(adj => {\r\n          visitList.add(adj);\r\n          if (!adj.getPred()) {\r\n            adj.setPred(node);\r\n          }\r\n        });\r\n      }\r\n    }\r\n    return visitedList;\r\n  }\r\n\r\n  dfs2(first) {\r\n    console.log(\"running dfs\");\r\n    const visited = new Map();\r\n    const visitList = new Stack();\r\n    this.setToInfinity();\r\n\r\n    visitList.push(first);\r\n\r\n    const visitedList = [];\r\n\r\n    while (!visitList.isEmpty()) {\r\n      const node = visitList.pop();\r\n      if (node && !visited.has(node)) {\r\n        visitedList.push(node.value);\r\n        visited.set(node);\r\n        node.getAdjacents().forEach(adj => {\r\n          visitList.push(adj);\r\n          if (!adj.getPred()) {\r\n            adj.setPred(node);\r\n          }\r\n        });\r\n      }\r\n    }\r\n    return visitedList;\r\n  }\r\n\r\n  setToInfinity(start) {\r\n    //BFS through setting to MAXSAFE INTEGER.\r\n    const visited = new Map();\r\n    const visitList = new Stack();\r\n    visitList.push(start);\r\n    while (!visitList.isEmpty()) {\r\n      const node = visitList.pop();\r\n      if (node && !visited.has(node)) {\r\n        visited.set(node);\r\n        node.setDistance(Number.MAX_SAFE_INTEGER);\r\n        node.setPred(null);\r\n        node.getAdjacents().forEach(adj => visitList.push(adj));\r\n      }\r\n    }\r\n  }\r\n\r\n  dijkstra(start) {\r\n    console.log(\"running dijkstra\");\r\n    graph.setToInfinity(start);\r\n    let dijkstra = [start];\r\n    let pq = new PriorityQueue();\r\n    start.setDistance(0);\r\n    for (let node of this.nodes) {\r\n      pq.add([node[1].getDistance(), node[1]]);\r\n    }\r\n    while (!pq.isEmpty()) {\r\n      let currentNode = pq.delMin();\r\n      // console.log('current:',currentNode.getValue())\r\n      for (let nextNode of currentNode.getAdjacents()) {\r\n        // console.log(' - :',nextNode.getValue())\r\n        let newDist =\r\n          currentNode.getDistance() + currentNode.getWeight(nextNode);\r\n        // console.log('new dist:' , newDist, 'next idst:', nextNode.getDistance())\r\n        if (newDist <= nextNode.getDistance()) {\r\n          nextNode.setDistance(newDist);\r\n          dijkstra.push(nextNode);\r\n          pq.decreaseKey(nextNode, newDist);\r\n          nextNode.setPred(currentNode);\r\n        }\r\n      }\r\n    }\r\n    return dijkstra.map(node => node.getValue());\r\n  }\r\n\r\n  a_star(startNode, endNode) {\r\n    console.log('running a * ');\r\n    let openList = [];\r\n    let closedList = [];\r\n    let visited = [startNode.getValue()];\r\n\r\n    startNode.g = startNode.h = startNode.f = 0;\r\n\r\n    endNode.g = endNode.h = endNode.f = 0;\r\n    let xEnd = endNode.getValue() % cols;\r\n    let yEnd = calculateY(endNode.getValue(), 0);\r\n\r\n    openList.push(startNode);\r\n    while (openList.length > 0) {\r\n      let current = openList[0];\r\n      let currentIndex = 0;\r\n      let index = 0;\r\n      for (let node of openList) {\r\n        if (node.f < current.f) {\r\n          current = node;\r\n          currentIndex = index;\r\n        }\r\n        index++;\r\n      }\r\n\r\n      openList = openList\r\n        .slice(0, currentIndex)\r\n        .concat(openList.slice(currentIndex + 1));\r\n      closedList.push(current);\r\n      if (current.getValue() === endNode.getValue()) {\r\n        let path = [];\r\n        let curr = current;\r\n        startNode.setPred(null)\r\n        while (curr) {\r\n          path.push(curr.getValue());\r\n          curr = curr.getPred();\r\n        }\r\n        return [path.reverse(), visited];\r\n      }\r\n\r\n      //iterate through adjacent\r\n      for (let node of current.getAdjacents()) {\r\n        visited.push(node.getValue());\r\n        let inClosedList = closedList.filter(\r\n          closedNode => node.getValue() === closedNode.getValue()\r\n        );\r\n        if (inClosedList.length === 0) {\r\n          //Create g,h,f for node\r\n          node.g = current.getWeight(node) + current.g;\r\n          //heuristic calc.\r\n          let xCurr = node.getValue() % cols;\r\n          let yCurr = calculateY(node.getValue(), 0);\r\n          node.h = Math.pow(xCurr - xEnd, 2) + Math.pow(yCurr - yEnd, 2);\r\n          node.f = node.h + node.g;\r\n\r\n          //If node in openList continue to beggining forloop\r\n          let cont = true;\r\n          for (let openNode of openList) {\r\n            if (\r\n              node.getValue() === openNode.getValue() &&\r\n              node.g >= openNode.g\r\n            ) {\r\n              cont = false;\r\n            }\r\n          }\r\n\r\n          if (cont) {\r\n            node.setPred(current);\r\n            openList.push(node);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  getAlgo(pos) {\r\n    let algos = [this.bfs2, this.dfs2, this.dijkstra, this.a_star];\r\n    return algos[pos];\r\n  }\r\n}\r\n\r\nGraph.UNDIRECTED = Symbol(\"undirected graph\"); // one-way edges\r\nGraph.DIRECTED = Symbol(\"directed graph\"); // two-ways edges\r\n\r\nexport default Graph;\r\n\r\nconst graph = new Graph(Graph.UNDIRECTED);\r\n\r\n// const [first] = graph.addEdge(1,2);\r\n// graph.addEdge(1, 3);\r\n// graph.addEdge(1, 4);\r\n// graph.addEdge(5, 2);\r\n// graph.addEdge(6, 3);\r\n// graph.addEdge(7, 3);\r\n// graph.addEdge(8, 4);\r\n// graph.addEdge(9, 5);\r\n// graph.addEdge(10, 6);\r\n\r\n// console.log(graph.bfs2(first));\r\n","export const rows = 11;\r\nexport const cols = 46;","import Graph from '../DataStructures/Graph';\r\nimport {cols, rows} from './constants';\r\n\r\n\r\nexport const addEdge = (graph, node) => {\r\n    if (!((node+1)%cols === 0)) {\r\n        graph.addEdge(node, node+1);\r\n        if (node+cols <( cols * rows) - 1) {\r\n            graph.addEdge(node, node+cols)\r\n        }\r\n    }\r\n    else {\r\n        if ((node+cols) <= (cols * rows) - 1 ) {\r\n            graph.addEdge(node, node+cols)\r\n        }\r\n    }\r\n}\r\n\r\nexport const restoreEdge = (graph, node) => {\r\n    if (node > cols && graph.getVertex(node-cols)) {\r\n        graph.addEdge(node, node-cols);\r\n    }\r\n    if ((!((node+1)%cols === 0)) && graph.getVertex(node+1) ) {\r\n        graph.addEdge(node, node+1);\r\n    }\r\n    if ( (node + cols <= (rows*cols))  && graph.getVertex(node+cols)) {\r\n        graph.addEdge(node, node+cols);\r\n    }\r\n    if ( (!(node % cols === 0)) && graph.getVertex(node-1)) {\r\n        graph.addEdge(node, node-1);\r\n    }\r\n}\r\n\r\nexport const addWeight = (graph, node, weight) => {\r\n    let nodeClicked = graph.getVertex(node);\r\n    let nodeAdj = graph.getVertex(node-cols);\r\n    const isUndirected = graph.edgeDirection === Graph.UNDIRECTED;\r\n    if (node > cols && nodeAdj) {\r\n        nodeClicked.setWeight(nodeAdj, weight);\r\n        if (isUndirected) {\r\n            nodeAdj.setWeight(nodeClicked, weight)\r\n        }\r\n    }\r\n    nodeAdj = graph.getVertex(node+1)\r\n    if ((!((node+1)%cols === 0)) && nodeAdj ) {\r\n        nodeClicked.setWeight(nodeAdj, weight);\r\n        if (isUndirected) {\r\n            nodeAdj.setWeight(nodeClicked, weight)\r\n        }\r\n    }\r\n    nodeAdj = graph.getVertex(node+cols);\r\n    if ( (node + cols <= (rows*cols))  && nodeAdj) {\r\n        nodeClicked.setWeight(nodeAdj, weight);\r\n        if (isUndirected) {\r\n            nodeAdj.setWeight(nodeClicked, weight)\r\n        }\r\n    }\r\n    nodeAdj = graph.getVertex(node-1);\r\n    if ( (!(node % cols === 0)) && graph.getVertex(node-1)) {\r\n        nodeClicked.setWeight(nodeAdj, weight);\r\n        if (isUndirected) {\r\n            nodeAdj.setWeight(nodeClicked, weight)\r\n        }\r\n    }\r\n}\r\n\r\nexport const generateGraph = () => {\r\n    const graph = new Graph(Graph.UNDIRECTED);\r\n    let total = rows*cols;\r\n    for (let count = 0; count<total; count++) {\r\n        addEdge(graph, count);\r\n    }\r\n    return graph;\r\n}\r\n\r\nexport const getPredList = (node, start) => {\r\n    let max = 1000;\r\n    let count = 0;\r\n    let done = false;\r\n    let list = [node.getValue()];\r\n    let current = node;\r\n    while (!done) {\r\n        if (!current.getPred() || count >= max || current.getValue() === start) {\r\n            done = true;\r\n        }\r\n        else {\r\n            count++;\r\n            current = current.getPred();\r\n            list.push(current.getValue());\r\n        }\r\n    }\r\n    return list.reverse();\r\n}\r\n","import {cols, rows} from './constants'\r\n\r\nexport const generateEmptyGrid = () => {\r\n    return new Array(rows*cols).fill(0);\r\n}\r\n","import {createSlice} from '@reduxjs/toolkit';\r\nimport {generateEmptyGrid} from './utils/helpersGrid';\r\nimport {cols, rows} from './utils/constants';\r\n\r\n\r\nconst initialState = {\r\n    selectedAlgorithm: 2,\r\n    visitPath: [],\r\n    foundPath: [],\r\n    grid: generateEmptyGrid(),\r\n    start: \"243\",\r\n    end: \"262\",\r\n    isDragging: false,\r\n    addingWall: false,\r\n    latestDrag: null,\r\n    itemDragging: null,\r\n    graphChange: {type:\"\", value:\"\"}\r\n};\r\n\r\nconsole.log((Math.floor(rows/2) + Math.floor(cols/4)*cols),(Math.floor(rows/2)*3 + Math.floor(cols/4)*cols) )\r\n\r\nconst algoSlice = createSlice({\r\n    name:'algo',\r\n    initialState: initialState,\r\n    reducers: {\r\n        setStart: {\r\n            reducer(state, action) {\r\n                state.start = action.payload.start\r\n            },\r\n            prepare(newStart) {\r\n                return { payload: {start:newStart}}\r\n            }\r\n        },\r\n        setEnd: {\r\n            reducer(state, action) {\r\n                state.end = action.payload.end\r\n            },\r\n            prepare(newEnd) {\r\n                return { payload: {end:newEnd}}\r\n            }\r\n        },\r\n        setGrid: {\r\n            reducer(state, action) {\r\n                state.grid[action.payload.index] = action.payload.value\r\n            },\r\n            prepare(index, value) {\r\n                return {payload: {index: index, value: value}}\r\n            }\r\n        },\r\n        clearGrid(state) {\r\n            state.grid = generateEmptyGrid()\r\n        },\r\n        setSelected: {\r\n            reducer(state, action) {\r\n                state.selectedAlgorithm = action.payload.value\r\n            },\r\n            prepare(val) {\r\n                return {payload: {value: val}}\r\n            }\r\n        },\r\n        setVisitPath: {\r\n            reducer(state,action) {\r\n                state.visitPath = action.payload.visitPath;\r\n            },\r\n            prepare(path) {\r\n                return {payload: {visitPath: path}}\r\n            }\r\n        },\r\n        setFoundPath(state, action) {\r\n            state.foundPath = action.payload.foundPath\r\n        },\r\n        setDragging: {\r\n            reducer(state, action) {\r\n                state.isDragging = action.payload.isDragging\r\n            },\r\n            prepare(b) {\r\n                return {payload: {isDragging:b}}\r\n            }\r\n        },\r\n        setAddingWall: {\r\n            reducer(state,action) {\r\n                state.addingWall = action.payload.isAdding\r\n            },\r\n            prepare(b) {\r\n                return {payload: {isAdding: b}}\r\n            }\r\n        },\r\n        setLatestDrag: {\r\n            reducer(state, action) {\r\n                state.latestDrag = action.payload.latest\r\n            },\r\n            prepare(newCell) {\r\n                return {payload: {latest: newCell}}\r\n            }\r\n        },\r\n        setItemDragging: {\r\n            reducer(state, action) {\r\n                state.itemDragging = action.payload.item\r\n            },\r\n            prepare(item) {\r\n                return {payload: {item: item}}\r\n            }\r\n        },\r\n        setGraphChange: {\r\n            reducer(state, action) {\r\n                state.graphChange = {type: action.payload.type, value: action.payload.value}\r\n            },\r\n            prepare(action) {\r\n                return {payload: {type: action.type, value:action.value}}\r\n            }\r\n        }\r\n        \r\n    }\r\n});\r\n\r\nexport const {setStart, setEnd, setGrid, setSelected, setVisitPath, setFoundPath, \r\n    clearGrid, setDragging, setAddingWall, setLatestDrag, setItemDragging, setGraphChange} = algoSlice.actions;\r\n\r\nexport default algoSlice.reducer;","import React, {useRef} from 'react'\r\nimport { connect } from 'react-redux';\r\nimport {setStart, setGrid, setLatestDrag, setDragging, setItemDragging, setGraphChange} from '../AlgoSlice';\r\n\r\nconst generateClassName = (value) => {\r\n    if (value === 1) {\r\n        return 'node-visited';\r\n    }\r\n    else if (value === \"WALL\") {\r\n        return 'node-wall'\r\n    }\r\n    else if (value === \"START\") {\r\n        return 'node-start'; \r\n    }\r\n    else if (value === \"END\") {\r\n        return 'node-end';\r\n    }\r\n    else if (value === \"WEIGHT\") {\r\n        return 'node-weight';\r\n    }\r\n    else if (value === \"FOUND\") {\r\n        return 'node-found';\r\n    }\r\n    else {\r\n        return ''\r\n    }\r\n}\r\n\r\nconst Cell2 = React.memo(({value, cellVal, setLatestDrag, setDragging, setItemDragging, addingWall, setGrid, setGraphChange}) => {\r\n\r\n    const handleClick = () => {\r\n        let newVal;\r\n        //ADDING WALL\r\n        if (addingWall) {\r\n            newVal = cellVal === \"WALL\" ? 0 : \"WALL\";\r\n            setGrid(value, newVal);\r\n            let obj = {type: `${newVal === 0 ? \"REMOVE_WALL\" : \"ADD_WALL\"}` , value: value}\r\n            setGraphChange(obj);\r\n        }\r\n\r\n        //ADDING WEIGHT\r\n        else {\r\n            newVal = cellVal === \"WEIGHT\" ? 0 : \"WEIGHT\";\r\n            setGrid(value, newVal);\r\n            let obj = {type: `${newVal === 0 ? \"REMOVE_WEIGHT\" : \"ADD_WEIGHT\"}` , value: value}\r\n            setGraphChange(obj);\r\n        }\r\n    }\r\n\r\n    return (\r\n        <div\r\n            draggable\r\n            onDragStart={() => {\r\n                if (cellVal === \"START\") {\r\n                    setItemDragging(\"START\");\r\n                    setDragging(true);\r\n                }\r\n                else if (cellVal === \"END\") {\r\n                    setItemDragging(\"END\");\r\n                    setDragging(true);\r\n                }\r\n            }}\r\n            onDragOver={(e) => setLatestDrag(e.target.getAttribute('value'))}\r\n            onDragEnd={() => {\r\n                setDragging(false);\r\n            }}\r\n            onClick={() => handleClick()}\r\n            value={value}\r\n            className={`node ${generateClassName(cellVal)}`}>\r\n        </div>\r\n    )\r\n})\r\n\r\nconst mapStateToProps = state => ({\r\n    addingWall: state.addingWall\r\n})\r\n\r\nconst mapDispatch = {setStart, setGrid, setLatestDrag, setDragging, setItemDragging, setGraphChange}\r\n\r\nexport default connect(mapStateToProps, mapDispatch)(Cell2);\r\n","import React, {useState, useCallback, useRef, useEffect} from 'react'\r\nimport {connect} from 'react-redux';\r\nimport {restoreEdge, addWeight, generateGraph ,getPredList} from '../utils/helpersGraph';\r\n\r\nimport {setStart, setEnd, setItemDragging} from '../AlgoSlice';\r\nimport {setGrid, clearGrid, setVisitPath, setDragging, setAddingWall,}  from '../AlgoSlice';\r\nimport Cell2 from './Cell2';\r\n\r\n\r\nconst Pathfinder = ({start, end, setStart, setEnd, grid, setGrid, clearGrid, \r\n    selectedAlgorithm, isDraggin, setVisitPath, setAddingWall, addingWall, latestDrag,itemDragging, setItemDragging, graphChange}) => {\r\n\r\n    const [graph, setGraph] = useState(() => {  \r\n       return generateGraph();\r\n    });\r\n\r\n\r\n    const gridRef = useRef(grid);\r\n    gridRef.current = grid;\r\n\r\n    //SETTING START AND END IN THE GRID.\r\n    useEffect(() => {\r\n        setGrid(parseInt(start),\"START\");\r\n        setGrid(parseInt(end),\"END\");\r\n    }, [start,end, graph]);\r\n\r\n    const [running, setRunning] = useState(false);\r\n    const runningRef = useRef(running);\r\n    runningRef.current = running;\r\n\r\n    // Ref for end to useCallback in runSimulation\r\n    const endRef = useRef(parseInt(end));\r\n    endRef.current = parseInt(end);\r\n    const startRef = useRef(parseInt(start));\r\n    startRef.current = parseInt(start);\r\n    const selectedRef = useRef(selectedAlgorithm);\r\n    selectedRef.current = selectedAlgorithm;\r\n\r\n    const isDraggingRef = useRef(isDraggin);\r\n    isDraggingRef.current = isDraggin;\r\n\r\n    const runSimulation = useCallback((visited, found=[], val=1) => {\r\n        let tmp = visited.map(n =>n);\r\n\r\n        const helper = async () => {\r\n            if (!runningRef.current || tmp.length === 0 ) {\r\n                setRunning(false);\r\n                return;\r\n            }\r\n            let idx = tmp[0];\r\n            if (idx === parseInt(endRef.current)) {\r\n                runSimulation(found, [],\"FOUND\");\r\n            }\r\n            else {\r\n                setGrid(idx, val);\r\n                tmp = tmp.splice(1);\r\n                setTimeout(helper, 1);\r\n            }\r\n        };\r\n        helper();\r\n    }, []);\r\n\r\n    const runClick = useCallback(() => {\r\n        setRunning(!runningRef.current);\r\n        runningRef.current = (!runningRef.current);\r\n        if (!running) {\r\n            let startNode = graph.getVertex(parseInt(startRef.current));\r\n            let endNode = graph.getVertex(parseInt(endRef.current));\r\n            let resList;\r\n            switch(selectedRef.current) {\r\n                //DFS and BFS\r\n                case 0:\r\n                case 1:\r\n                case 2:\r\n                    let path = graph.getAlgo(selectedRef.current).bind(graph)(startNode);\r\n                    setVisitPath(path)\r\n                    resList = getPredList(endNode, parseInt(startRef.current));\r\n                    runSimulation(path, resList);\r\n                    break;\r\n                case 3:\r\n                    let paths = graph.getAlgo(selectedRef.current).bind(graph)(startNode, endNode);\r\n                    setVisitPath(paths[1]);\r\n                    runSimulation(paths[1], paths[0]);\r\n                default:\r\n                    return;\r\n            }\r\n        }\r\n    }, [graph]);\r\n\r\n    const handleClear = () => {\r\n        const newGraph = generateGraph();\r\n        setGraph(newGraph);\r\n        clearGrid();\r\n    }\r\n\r\n\r\n    const removeOthers = () => {\r\n        grid.map((cell, idx) => {\r\n            if (cell !== 0) {\r\n                if (idx === start || idx === end || grid[idx] === \"WALL\" || grid[idx] === \"WEIGHT\") {\r\n                    \r\n                }\r\n                else {\r\n                    setGrid(idx, 0);\r\n                }\r\n            }\r\n        }\r\n        ) \r\n    }\r\n\r\n    //Drag handler\r\n    useEffect(() => {\r\n        if (latestDrag && !isDraggin) {\r\n            if (itemDragging === \"START\") {\r\n                setStart(latestDrag);\r\n                removeOthers();\r\n                setItemDragging(null);\r\n            }\r\n            else if (itemDragging === \"END\") {\r\n                setEnd(latestDrag)\r\n                removeOthers();\r\n                setItemDragging(null)\r\n            }\r\n        }\r\n    }, [latestDrag, isDraggin]);\r\n\r\n    useEffect(() => {\r\n        let value = graphChange.value;\r\n        let type = graphChange.type;\r\n        let weight;\r\n        switch(type) {\r\n            case \"ADD_WALL\":\r\n                graph.removeVertex(value);\r\n                break;\r\n            case \"REMOVE_WALL\":\r\n                graph.addVertex(value);\r\n                restoreEdge(graph, value);\r\n                break;\r\n            case \"ADD_WEIGHT\":\r\n                weight = 10;\r\n                addWeight(graph, value,weight);\r\n                break;\r\n            case \"REMOVE_WEIGHT\":\r\n                weight = 1;\r\n                addWeight(graph, value,weight);\r\n                break;\r\n        }\r\n    }, [graphChange]);\r\n\r\n    return (\r\n        <div className=\"container\">\r\n            <div className=\"grid\">\r\n                {grid.map((cell, idx) =>\r\n                <Cell2 value={idx} cellVal={cell} key={idx} />\r\n                )}  \r\n            </div>\r\n            <div>\r\n            </div>    \r\n            <div className=\"buttons\">\r\n                <button className=\"button\" onClick={() => runClick()}>{running ? 'STOP' : 'START'}</button>\r\n                <button className=\"button\" onClick={() => handleClear()}>Clear All</button>\r\n                <button className=\"button\" onClick={() => setAddingWall(!addingWall)}>{addingWall ? \"Adding Wall\" : \"Adding weight\"}</button>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nconst mapStateToProps = state => ({\r\n    start: state.start,\r\n    end: state.end,\r\n    grid: state.grid,\r\n    path: state.visitPath,\r\n    selectedAlgorithm: state.selectedAlgorithm,\r\n    isDraggin: state.isDragging,\r\n    addingWall: state.addingWall,\r\n    latestDrag: state.latestDrag,\r\n    itemDragging: state.itemDragging,\r\n    graphChange: state.graphChange\r\n})\r\n\r\nconst mapDispatchToProps = {setStart, setEnd, setGrid, clearGrid, setVisitPath, setDragging, setAddingWall, setItemDragging}\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(Pathfinder);","import React from 'react'\r\nimport { connect } from 'react-redux';\r\nimport {setSelected} from '../AlgoSlice';\r\n\r\n\r\n\r\nconst Header = ({setSelected}) => {\r\n\r\n    const handleDropdownChange = e => {\r\n        setSelected(parseInt(e.target.value));\r\n    }\r\n\r\n    return (\r\n        <div className=\"header\">\r\n            <div className=\"logo\">\r\n                Pathfinder visualizer\r\n            </div>\r\n            <span className=\"select-name\">Selected algorithm:</span>\r\n            <select defaultValue={2} className=\"select\" onChange={(e) => handleDropdownChange(e)} name=\"\" id=\"\">\r\n                    <option value={0}>BFS</option>\r\n                    <option value={1}>DFS</option>\r\n                    <option value={2}>Dijkstra</option>\r\n                    <option value={3}>A*</option>\r\n            </select>\r\n        </div>\r\n    )\r\n}\r\n\r\nconst mapStateToProps = state => ({\r\n    selected: state.selectedAlgorithm\r\n})\r\nconst mapDispatchToProps = {setSelected}\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(Header);\r\n","import React from 'react'\r\nimport { connect } from 'react-redux'\r\n\r\nconst algoList = [\"Breadth first search\", \"Depth first search\", \"Dijkstra\" ,\"A*\"]\r\nconst getInfo = selected => {\r\n    switch(selected) {\r\n        case 0:\r\n            return \"BFS gives us the shortest path for an unweighted undirected graph, it is used as a traversal graph algorithm.\"\r\n        case 1:\r\n            return \"DFS does NOT give us the shortest path, it is used as a traversal graph algorithm\"\r\n        case 2:\r\n            return \"Dijkstra gives us the shortest path for weighted undirected or directed graphs. It is the most common shortest path algorithm\"\r\n        case 3:\r\n            return \"A* is a variation of the informed search graphs. It uses an heuristic to get the shortest path faster.\"\r\n\r\n    }\r\n}\r\n\r\nconst Info = ({selected, addingWall}) => {\r\n\r\n\r\n    return (\r\n        <div className=\"algo-info\">\r\n            <p className=\"info-text\">\r\n                You have selected the {algoList[selected]} algorithm. <br></br>\r\n                {getInfo(selected)}. <br></br>\r\n                You are currently {addingWall ? \" adding wall\" : \" adding weight\"} (press to any cell in the grid to add a {addingWall ? \" wall\" : \" weight\"}).\r\n                {addingWall ? \" Walls are impassable.\" : \" Passing through a weight costs 10 times more than passing through a blank cell.\"}<br></br>\r\n                Drag and drop either the green cell (start) or the orange one (end) to change the path.\r\n            </p>\r\n            <div className=\"legend\">\r\n                <p>\r\n                    <span className=\"legend-color legend-color__start\"></span> <span>Start</span>\r\n                </p>\r\n                <p>\r\n                   <span className=\"legend-color legend-color__end\"></span> <span>End</span>\r\n                </p>\r\n                <p>\r\n                    <span className=\"legend-color legend-color__wall\"></span> <span>Wall</span>\r\n                </p>\r\n                <p>\r\n                    <span className=\"legend-color legend-color__weight\"></span> <span>Weight</span>\r\n                </p>\r\n                <p>\r\n                    <span className=\"legend-color legend-color__visited\"></span> <span>Visited cell</span>\r\n                </p>\r\n                <p>\r\n                    <span className=\"legend-color legend-color__found\"></span> <span>Shortest path cell</span>\r\n                </p>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nconst mapStateToProps = state => ({\r\n    selected: state.selectedAlgorithm,\r\n    addingWall: state.addingWall\r\n})\r\n\r\nexport default connect(mapStateToProps,null)(Info);\r\n","import React from 'react';\nimport './App.css';\nimport Pathfinder from './components/Pathfinder';\nimport Header from './components/Header';\nimport Info from './components/Info';\n\nfunction App() {\n  return (\n    <div className=\"app\">\n      <Header />\n      <Info />\n      <Pathfinder />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport { configureStore } from '@reduxjs/toolkit'\nimport { Provider } from 'react-redux'\nimport algoReducer from './AlgoSlice';\n\nconst store = configureStore({\n    reducer: algoReducer\n})\n\nReactDOM.render(\n    <Provider store={store}>\n        <App />\n    </Provider>,\n    document.getElementById('root'));"],"sourceRoot":""}